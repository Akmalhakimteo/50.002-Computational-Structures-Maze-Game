/*
   This file was generated automatically by the Mojo IDE version B1.3.6.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module fsm_controller_25 (
    input clk,
    input rst,
    input decrease_timer,
    input up,
    input down,
    input left,
    input right,
    input hint,
    input [7:0] rom_data,
    input [2:0] x_location,
    input [2:0] y_location,
    input [2:0] temp_location_1,
    input [2:0] temp_location_2,
    input timer_decrease,
    input dificulity_level,
    output reg [5:0] alufn,
    output reg [2:0] xsel,
    output reg [2:0] ysel,
    output reg we_regfile,
    output reg we_regfile_1,
    output reg [4:0] regfile_write_address,
    output reg [4:0] regfile_write_address_1,
    output reg [4:0] regfile_read_address_a,
    output reg [4:0] regfile_read_address_b,
    output reg [4:0] regfile_read_address_c,
    output reg [1:0] wdsel,
    output reg [3:0] rom_address,
    output reg win_signal,
    output reg lose_signal,
    output reg [15:0] direct_data,
    output reg decctr_decrease
  );
  
  
  
  reg new_x;
  
  reg new_y;
  
  reg check_wall;
  
  reg win;
  
  reg lose;
  
  localparam START_TIMER_maze_fsm = 4'd0;
  localparam START_SETX_maze_fsm = 4'd1;
  localparam START_SETY_maze_fsm = 4'd2;
  localparam IDLE_maze_fsm = 4'd3;
  localparam CHECK_GAME_TIMER_maze_fsm = 4'd4;
  localparam UPDATE_maze_fsm = 4'd5;
  localparam CHECKMOVEMENT_UP_maze_fsm = 4'd6;
  localparam CHECKMOVEMENT_DOWN_maze_fsm = 4'd7;
  localparam CHECKMOVEMENT_LEFT_maze_fsm = 4'd8;
  localparam CHECKMOVEMENT_RIGHT_maze_fsm = 4'd9;
  localparam CHECKMOVEMENT_UP_WALL_maze_fsm = 4'd10;
  localparam CHECKMOVEMENT_DOWN_WALL_maze_fsm = 4'd11;
  localparam CHECKMOVEMENT_LEFT_WALL_maze_fsm = 4'd12;
  localparam CHECKMOVEMENT_RIGHT_WALL_maze_fsm = 4'd13;
  localparam WIN_maze_fsm = 4'd14;
  localparam LOSE_maze_fsm = 4'd15;
  
  reg [3:0] M_maze_fsm_d, M_maze_fsm_q = START_TIMER_maze_fsm;
  reg [7:0] M_timer_reg_d, M_timer_reg_q = 1'h0;
  
  always @* begin
    M_maze_fsm_d = M_maze_fsm_q;
    M_timer_reg_d = M_timer_reg_q;
    
    win_signal = 1'h0;
    lose_signal = 1'h0;
    alufn = 1'h0;
    xsel = 1'h0;
    ysel = 1'h0;
    we_regfile = 1'h0;
    we_regfile_1 = 1'h0;
    regfile_write_address = 14'h2b67;
    regfile_write_address_1 = 14'h2b67;
    regfile_read_address_a = 1'h0;
    regfile_read_address_b = 1'h0;
    regfile_read_address_c = 1'h0;
    wdsel = 1'h0;
    rom_address = 1'h0;
    direct_data = 1'h0;
    decctr_decrease = 1'h0;
    if (rst) begin
      M_maze_fsm_d = START_TIMER_maze_fsm;
    end else begin
      
      case (M_maze_fsm_q)
        START_TIMER_maze_fsm: begin
          M_timer_reg_d = 7'h64;
          M_maze_fsm_d = START_SETX_maze_fsm;
        end
        START_SETX_maze_fsm: begin
          alufn = 6'h00;
          xsel = 3'h0;
          ysel = 3'h0;
          regfile_write_address = 5'h00;
          we_regfile = 1'h1;
          wdsel = 2'h1;
          M_maze_fsm_d = START_SETY_maze_fsm;
        end
        START_SETY_maze_fsm: begin
          alufn = 6'h00;
          xsel = 3'h0;
          ysel = 3'h0;
          regfile_write_address = 5'h01;
          we_regfile = 1'h1;
          wdsel = 2'h1;
          M_maze_fsm_d = IDLE_maze_fsm;
        end
        CHECKMOVEMENT_UP_maze_fsm: begin
          alufn = 6'h01;
          xsel = 5'h00;
          ysel = 5'h01;
          regfile_read_address_a = 5'h01;
          regfile_write_address = 5'h02;
          we_regfile = 1'h1;
          wdsel = 2'h0;
          M_maze_fsm_d = CHECKMOVEMENT_UP_WALL_maze_fsm;
        end
        CHECKMOVEMENT_UP_WALL_maze_fsm: begin
          if (temp_location_1 > 1'h0) begin
            rom_address = temp_location_1;
            check_wall = rom_data[(3'h7 - x_location)*1+0-:1];
            if (check_wall == 1'h1) begin
              alufn = 6'h1a;
              regfile_write_address = 5'h01;
              we_regfile = 1'h1;
              xsel = 2'h2;
              wdsel = 2'h0;
              direct_data = temp_location_1;
              M_maze_fsm_d = IDLE_maze_fsm;
            end else begin
              M_maze_fsm_d = IDLE_maze_fsm;
            end
          end else begin
            M_maze_fsm_d = IDLE_maze_fsm;
          end
        end
        CHECKMOVEMENT_DOWN_maze_fsm: begin
          alufn = 6'h00;
          xsel = 5'h00;
          ysel = 5'h01;
          regfile_read_address_a = 5'h01;
          regfile_write_address = 5'h02;
          we_regfile = 1'h1;
          wdsel = 2'h0;
          M_maze_fsm_d = CHECKMOVEMENT_DOWN_WALL_maze_fsm;
        end
        CHECKMOVEMENT_DOWN_WALL_maze_fsm: begin
          if (temp_location_1 > 1'h0) begin
            rom_address = temp_location_1;
            check_wall = rom_data[(3'h7 - x_location)*1+0-:1];
            if (check_wall) begin
              alufn = 6'h1a;
              regfile_write_address = 5'h01;
              we_regfile = 1'h1;
              xsel = 2'h2;
              wdsel = 2'h0;
              direct_data = temp_location_1;
              M_maze_fsm_d = IDLE_maze_fsm;
            end else begin
              M_maze_fsm_d = IDLE_maze_fsm;
            end
          end else begin
            M_maze_fsm_d = IDLE_maze_fsm;
          end
        end
        CHECKMOVEMENT_LEFT_maze_fsm: begin
          alufn = 6'h01;
          xsel = 5'h00;
          ysel = 5'h01;
          regfile_read_address_a = 5'h00;
          regfile_write_address = 5'h02;
          we_regfile = 1'h1;
          wdsel = 2'h0;
          M_maze_fsm_d = CHECKMOVEMENT_LEFT_WALL_maze_fsm;
        end
        CHECKMOVEMENT_LEFT_WALL_maze_fsm: begin
          if (temp_location_1 > 1'h0) begin
            rom_address = y_location;
            check_wall = rom_data[(3'h7 - temp_location_1)*1+0-:1];
            if (check_wall == 1'h1) begin
              alufn = 6'h1a;
              regfile_write_address = 5'h00;
              we_regfile = 1'h1;
              xsel = 2'h2;
              wdsel = 2'h0;
              direct_data = temp_location_1;
              M_maze_fsm_d = IDLE_maze_fsm;
            end else begin
              M_maze_fsm_d = IDLE_maze_fsm;
            end
          end else begin
            M_maze_fsm_d = IDLE_maze_fsm;
          end
        end
        CHECKMOVEMENT_RIGHT_maze_fsm: begin
          alufn = 6'h00;
          xsel = 5'h00;
          ysel = 5'h01;
          regfile_read_address_a = 5'h00;
          regfile_write_address = 5'h02;
          we_regfile = 1'h1;
          wdsel = 2'h0;
          M_maze_fsm_d = CHECKMOVEMENT_RIGHT_WALL_maze_fsm;
        end
        CHECKMOVEMENT_RIGHT_WALL_maze_fsm: begin
          if (temp_location_1 > 1'h0) begin
            rom_address = y_location;
            check_wall = rom_data[(3'h7 - temp_location_1)*1+0-:1];
            if (check_wall == 1'h1) begin
              alufn = 6'h1a;
              regfile_write_address = 5'h00;
              we_regfile = 1'h1;
              xsel = 2'h2;
              wdsel = 2'h0;
              direct_data = temp_location_1;
              M_maze_fsm_d = IDLE_maze_fsm;
            end else begin
              M_maze_fsm_d = IDLE_maze_fsm;
            end
          end else begin
            M_maze_fsm_d = IDLE_maze_fsm;
          end
        end
        WIN_maze_fsm: begin
          win_signal = 1'h1;
          M_maze_fsm_d = START_TIMER_maze_fsm;
        end
        IDLE_maze_fsm: begin
          if (up) begin
            M_maze_fsm_d = CHECKMOVEMENT_UP_maze_fsm;
          end else begin
            if (down) begin
              M_maze_fsm_d = CHECKMOVEMENT_DOWN_maze_fsm;
            end else begin
              if (left) begin
                M_maze_fsm_d = CHECKMOVEMENT_LEFT_maze_fsm;
              end else begin
                if (right) begin
                  M_maze_fsm_d = CHECKMOVEMENT_RIGHT_maze_fsm;
                end else begin
                  if (hint) begin
                    
                  end else begin
                    if (timer_decrease) begin
                      if (M_timer_reg_q > 1'h0) begin
                        M_timer_reg_d = M_timer_reg_q - 1'h1;
                        decctr_decrease = 1'h1;
                      end else begin
                        lose_signal = 1'h1;
                      end
                    end else begin
                      if (x_location == 3'h7 && y_location == 3'h7) begin
                        M_maze_fsm_d = WIN_maze_fsm;
                      end
                    end
                  end
                end
              end
            end
          end
        end
      endcase
    end
  end
  
  always @(posedge clk) begin
    M_maze_fsm_q <= M_maze_fsm_d;
    
    if (rst == 1'b1) begin
      M_timer_reg_q <= 1'h0;
    end else begin
      M_timer_reg_q <= M_timer_reg_d;
    end
  end
  
endmodule
